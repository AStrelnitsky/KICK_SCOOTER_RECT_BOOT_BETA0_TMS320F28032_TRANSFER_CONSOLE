#define OPEN_WATCOM_DIRTY_HACK
#include "Base_Set.rc"
#endif
//#include <windows.h> г¦Ґ ўЄ«озҐ­® ў Јап§­®¬ е ЄҐ
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <math.h>

#include <commctrl.h>   //’анЄЎ ал (б« ©¤Ґал)

#include "DiaWrap.h"
#include "Protocol.h"

//HINSTANCE hinst;

FWAPI *DialogEngine=NULL, *NetEngine=NULL;
int MyDialogID=0;
HGLOBAL DiaTemplate;
int* IncomingBuffer=NULL;

fstream Log;
int DoLog=0, DoWarning=0;
unsigned long TrakDeadTime;     //Ї®б«Ґ «оЎ®© ®вЇа ўЄЁ ­ бв®ҐЄ бЁбвҐ¬  ¤®«¦­  Ўлвм Є Єго-в® ¤®«о бҐЄг­¤л Ј«ге  Є Ї®«§г­Є ¬.

char GraphArea[768*256*3]={0};

enum    //Љ®­ЄаҐв­® аҐЈЁбвал. U32 гЄ §лў овбп Є Є ¬« ¤иЁ©-бв аиЁ©, U8 гЄ §лў овбп Є Є Ї®«Ґ1_Ї®«Ґ2.
{
TIME_STAMP,
FREQUANCY,
WAVEFORM,
PWM,
I_U,
MEAN_OUT_ILIM,
PULSE_OUT_ILIM,
VOUT_LIM,
VIN_OV_LIM,
VIN_UV_LIM,
IIN_OC_LIM,
IOUT_OC_LIM,
OT1_LIM,
OT2_LIM,
PFC_T_INDUCTOR_LIM,
PFC_T_BRIDGE_LIM,
SS_PWM,
SS_FREQ,
SS_CURR,
T_PID_LSB,
T_PID_MSB,
KI_PID,
KP_PID,
KD_PID,
TI_LSB,
TI_MSB,
ThH1,
ThH2,
Kerr,

TOTAL_REGS
} ModbusMainList;

enum    //Љ®­ЄаҐв­® аҐЈЁбвал. U32 гЄ §лў овбп Є Є ¬« ¤иЁ©-бв аиЁ©, U8 гЄ §лў овбп Є Є Ї®«Ґ1_Ї®«Ґ2.
{
ADC_TIMESTAMP,
I_IN         ,
V_IN         ,
I_OUT        ,
V_OUT        ,
W_IN         ,
W_OUT         ,
P_IN         ,
Tb1_Tb2          ,
Tpfc_Tpfc_b       ,
Light        ,
F_m          ,
PWM_m        ,
I_U_m        ,
Ph_I         ,
ei           ,
acc_i        ,
PID_out      ,
reserve1     ,
reserve2     ,
reserve3     ,
reserve4     ,
reserve5     ,
reserve6     ,
reserve7     ,
reserve8     ,
reserve9     ,
reservea     ,
reserveb     ,
reservec     ,
reserved     ,
reservee     ,
reservef     ,
reserveg     ,
reserveh     ,
reservei     ,
reservej     ,
reservek     ,
STATUS       ,

TOTAL_ADC
} ModbusADCList;

#pragma pack (push)
#pragma pack (0)

struct tModbusMain      //’®¦Ґ Є®­ЄаҐв­® аҐЈЁбвал б Ёе г¬®«з «м­л¬Ё §­ зҐ­Ёп¬Ё.
{
    int Addr, Count;
    unsigned short Regs [TOTAL_REGS];
} ModbusMain = {40176+39, TOTAL_REGS,
    5,
    0xC,
    0,
    0x64,
    0,
    0x0B,
    0x0D,
    0,
    0xDC,
    0x96, 
    0xA0, 
    0x78, 
    0x4B,
    0x4B,
    0x4B,
    0x4B,
    0xA,
    0xA,
    0xA,
    0,  
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0x1388};

#define TOTAL_SETUP_FLAG_BYTES 2
struct
{
    int Addr, Count;
    unsigned char Bytes [TOTAL_SETUP_FLAG_BYTES];
} ModbusSETFlags = {33, TOTAL_SETUP_FLAG_BYTES*8};

#pragma pack (pop)

struct
{
    double Scale;
    int ControlId;
    char ToolTip[128];
}  ModbusMainGUI[TOTAL_REGS] =
{
1,  SET_TIME_STAMP,         "Шаг отметки времени телеметрии, mS",
10, SET_FREQUANCY,          "Заданная частота генерации, kHz",
1,  SET_WAVEFORM,           "Заданная форма сигнала (резерв)",
1,  SET_PWM,                "Заданный Коэффициент заполнения, %",
10, SET_I_U,                "Заданное значение стабилизации по току, A",
10, SET_MEAN_OUT_ILIM,      "Предел ограничения по среднему выходному току (программный, A)",
10, SET_PULSE_OUT_ILIM,     "Предел ограничения по импульcному выходному току (программный, A)",
2,  SET_VOUT_LIM,           "Предел ограничения по выходному напряжению (программный, Резерв, V)",
2,  SET_VIN_OV_LIM,         "Предел защиты по входному перенапряжению, V",
2,  SET_VIN_UV_LIM,         "Предел защиты по входному недонапряжению, V",
10, SET_IIN_OC_LIM,         "Предел защиты, A",
10, SET_IOUT_OC_LIM,        "Резерв, A",
1,  SET_OT1_LIM,            "Предел тепловой защиты первого полумоста генератора (резерв, C)",
1,  SET_OT2_LIM,            "Предел тепловой защиты второго полумоста генератора (резерв, C)",
1,  SET_PFC_T_INDUCTOR_LIM, "Предел тепловой защиты ключей PFC (резерв, C)",
1,  SET_PFC_T_BRIDGE_LIM,   "Предел тепловой защиты моста PFC (резерв, C)",
1,  SET_SS_PWM,             "Скорость нарастания PWM, %/s",
10, SET_SS_FREQ,            "Скорость нарастания частоты, kHz/s",
10, SET_SS_CURR,            "Скорость нарастания тока, A/s",
1,  SET_T_PID_LSB,          "Младший полубайт постоянной времени PID регулятора, 1 us",
1,  SET_T_PID_MSB,          "Старший полубайт постоянной времени PID регулятора, 1 us",
10, SET_KI_PID,             "Коэффициент интегрирования ПИД регулятора, promille",
10, SET_KP_PID,             "Коэффициент прямой ветви ПИД регулятора, promille",
10, SET_KD_PID,             "Коэффициент дифференциирующей ветви ПИД регулятора, promille",
1,  SET_TI_LSB,             "Младший полубайт постоянной времени интегратора, 1 us",
1,  SET_TI_MSB,             "Старший полубайт постоянной времени интегратора, 1 us",
10, SET_ThH1,               "Верхний предел насыщения интегратора PID регулятора, A",
10, SET_ThH2,               "Нижний предел насыщения интегратора PID регулятора, A",
5,  SET_Kerr,               "Коэффициент усиления ошибки, promille"
};

struct
{
	double Min, Max;
	char INIKeyName[64];
} ModbusMainINI[TOTAL_REGS] =
{
	NAN, NAN, "TIME_STAMP",
	NAN, NAN, "FREQUENCY",
	NAN, NAN, "WAVEFORM",
	NAN, NAN, "PWM",
	NAN, NAN, "I_U",
	NAN, NAN, "MEAN_OUT_ILIM",
	NAN, NAN, "PULSE_OUT_ILIM",
	NAN, NAN, "VOUT_LIM",
	NAN, NAN, "VIN_OV_LIM",
	NAN, NAN, "VIN_UV_LIM",
	NAN, NAN, "IIN_OC_LIM",
	NAN, NAN, "IOUT_OC_LIM",
	NAN, NAN, "OT1_LIM",
	NAN, NAN, "OT2_LIM",
	NAN, NAN, "PFC_T_INDUCTOR_LIM",
	NAN, NAN, "PFC_T_BRIDGE_LIM",
	NAN, NAN, "SS_PWM",
	NAN, NAN, "SS_FREQ",
	NAN, NAN, "SS_CURR",
	NAN, NAN, "T_PID_LSB",
	NAN, NAN, "T_PID_MSB",
	NAN, NAN, "KI_PID",
	NAN, NAN, "KP_PID",
	NAN, NAN, "KD_PID",
	NAN, NAN, "TI_LSB",
	NAN, NAN, "TI_MSB",
	NAN, NAN, "ThH1",
	NAN, NAN, "ThH2",
	NAN, NAN, "Kerr"
};

struct
{
	int CheckboxId;
	char ToolTip[128];
	char INIKeyName[64];
} ModbusSETFlagsGUI[TOTAL_SETUP_FLAG_BYTES*8] = {
SET_CB_I_LOOP			,"Включение/выключение стабилизации по выходному току",           "CB_I_LOOP",
SET_CB_I_LOOP_B			,"Включение/выключение стабилизации по току полумостов (Резерв)", "CB_I_LOOP_B",
SET_CB_F_LOOP			,"Включение автоподстройки частоты",                              "CB_F_LOOP",
SET_CB_I_PROFILE		,"Запуск сканирования профиля тока",                              "CB_I_PROFILE",
SET_CB_I_PROFILE_WRITE		,"Разрешение записи профиля тока",                                "CB_I_PROFILE_WRITE",
SET_CB_I_PROFILE_DEFAULT	,"Разрешение загрузки профиля тока по умолчанию",                 "CB_I_PROFILE_DEFAULT",
SET_CB_F_SCAN			,"Резерв",                                                        "CB_F_SCAN",
MEA_CB_reserve			,"Резерв",                                                        "",
MEA_CB_reserve			,"Резерв",                                                        "",
MEA_CB_reserve			,"Резерв",                                                        "",
MEA_CB_reserve			,"Резерв",                                                        "",
MEA_CB_reserve			,"Резерв",                                                        "",
MEA_CB_reserve			,"Резерв",                                                        "",
MEA_CB_reserve			,"Резерв",                                                        "",
MEA_CB_reserve			,"Резерв",                                                        "",
MEA_CB_reserve			,"Резерв"                                                         "",
};

char ParamHeaderString[] = "MixedPlugin	Minimum	Current Value	Maximum	#Graph. Color";

int GrabUserInput (tModbusMain *Dest)      //‡ Ї®«­пҐв ўбҐ Ї®«п, а §¬Ґа ­Ґ Їа®бв ў«пҐв (®­ ®ЇаҐ¤Ґ«пҐвбп ­ §­ зҐ­ЁҐ¬ Ї ЄҐв , в. Ґ. ­ ¦ в®© Є­®ЇЄ®©).
{
        unsigned long Msg[4]={0, BM_GETCHECK};

        double T;
//      Dest->AutoSend = 0;
        memset ((char*)Dest+8, 0, sizeof(tModbusMain)-8);

        for (int i=0; i<Dest->Count; i++)
                if (isfinite(T= *((double*)((*DialogEngine)(TEXTTODOUBLE, MyDialogID, ModbusMainGUI[i].ControlId     ))) ))
                {
                	if (!isnan(ModbusMainINI[i].Max) && T > ModbusMainINI[i].Max)	//Never TRUE if Max is NAN
                	{
                		Msg[0]=ModbusMainGUI[i].ControlId;
                                *((double*)(Msg+1)) = ModbusMainINI[i].Max;
                                (*DialogEngine) (DOUBLETOTEXT, MyDialogID, (int)Msg);
                                (*DialogEngine) (SETFOCUS    , MyDialogID, ModbusMainGUI[i].ControlId);
                                MessageBeep(MB_ICONHAND);
                                return 1;
                	}
                	if (!isnan(ModbusMainINI[i].Min) && T < ModbusMainINI[i].Min)	//Never TRUE if Min is NAN
                	{
                		Msg[0]=ModbusMainGUI[i].ControlId;
                                *((double*)(Msg+1)) = ModbusMainINI[i].Min;
                                (*DialogEngine) (DOUBLETOTEXT, MyDialogID, (int)Msg);
                                (*DialogEngine) (SETFOCUS    , MyDialogID, ModbusMainGUI[i].ControlId);
                                MessageBeep(MB_ICONHAND);
                                return 1;
                	}
                	Dest->Regs[i]         = T * ModbusMainGUI[i].Scale;
                }
                else	return MessageBeep(MB_ICONHAND) | 1;

		//Љ®¤ ЇаҐўа вЁ«бп ў ўлаўЁЈ« §­л© Ё­¤Ё©бЄЁ© ЇЁ§¤Ґж, ­® б а §¤Ґ«Ґ­ЁҐ¬ Ї« ЈЁ­®ў нв®в ¬®¬Ґ­в ЁбЇа ўЁвбп б ¬ Ї® бҐЎҐ.

        memset ((char*)&ModbusSETFlags+8, 0, sizeof(ModbusSETFlags)-8);
        for (int i=0; i<TOTAL_SETUP_FLAG_BYTES*8; i++)
        	if (ModbusSETFlagsGUI[i].CheckboxId != MEA_CB_reserve) 
		        ModbusSETFlags.Bytes[i/8] |= ( 
		          (*DialogEngine) ( SENDMDIALOG, MyDialogID, (int)&(Msg[0]=ModbusSETFlagsGUI[i].CheckboxId) ) != 0
		        )<<(i%8); //Don't set unknown flags!


        Msg[0]=SLIDERFREQ, Msg[1]=TBM_SETPOS, Msg[2]=(WPARAM)(BOOL)TRUE, Msg[3]=*((double*)((*DialogEngine)(TEXTTODOUBLE, MyDialogID, SET_FREQUANCY ))) * ModbusMainGUI[FREQUANCY].Scale;
        (*DialogEngine) ( SENDMDIALOG, MyDialogID, (int)Msg);
        Msg[0]=SLIDERAMPL,                                               Msg[3]=*((double*)((*DialogEngine)(TEXTTODOUBLE, MyDialogID, SET_I_U       ))) * ModbusMainGUI[I_U      ].Scale;
        (*DialogEngine) ( SENDMDIALOG, MyDialogID, (int)Msg);

        return 0;
}


int DoButton (int Button)
{
        unsigned long Msg[4]={/*ACK_PERM*/-1, BM_SETCHECK, BST_CHECKED};
        char* NameSet[5]={0};
        char Name[MAX_PATH]="Log.xls";
        int i;
        int pU32;

        switch (Button)
        {
                case ASK_CURR:
//                        Message.Hdr=MSG_DEBUG | CAT_MODE;
                        pU32 = (*NetEngine) (SEND_REQUEST, MyDialogID, (unsigned long)(&ModbusMain));
cout<<"Ptr returned:"<<pU32<<endl;
                        if (pU32)
                        {
                            memcpy (&ModbusMain, (int*)pU32, sizeof (ModbusMain));
cout<<"Regs read: "<<ModbusMain.Count<<endl;
                            for (i=0; i<ModbusMain.Count; i++)
                            {
                                Msg[0]=ModbusMainGUI[i].ControlId;
                                *((double*)(Msg+1))=((double)(ModbusMain.Regs[i])) / ModbusMainGUI[i].Scale;
                                (*DialogEngine) (DOUBLETOTEXT, MyDialogID, (int)Msg);
                            }
                        } else cout<<"Error! No data received"<<endl;	//ToDo: Log line!!!

		        pU32 = (*NetEngine) (SEND_REQUEST, MyDialogID, (unsigned long)(&ModbusSETFlags));
		        Msg[1]=BM_SETCHECK;
		        Msg[3]=0;
		        if (pU32)
		        {
		                memcpy (&ModbusSETFlags, (int*)pU32, sizeof (ModbusSETFlags));
		                for (int i=0; i<TOTAL_SETUP_FLAG_BYTES*8; i++)
		                {
				        Msg[0]=ModbusSETFlagsGUI[i].CheckboxId;
				        Msg[2]=(ModbusSETFlags.Bytes[i/8]>>(i%8)) & 1;
				        (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
				}
			} else cout<<"Error! No Setup Flags received"<<endl;	//ToDo: Log line!!!

                return 1;
//                case ASK_PERM:
//return 1 | RequestADC();
/*                        Msg[2]=BST_UNCHECKED;
                        Msg[0]=ACK_CURR    ,            (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=ACK_PERM    ,            (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);

                        Msg[1]=WM_SETTEXT;
                        Msg[2]=0;
                        Msg[3]=(int)"?";
                        Msg[0]=SET_RSVD  ,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=SET_FREQ  ,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=SET_WFORM ,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=SET_AMPL  ,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=SET_MILIM ,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=SET_LOOPS ,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=SET_RAMP  ,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=SET_VILIM ,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=SET_VOLIM ,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=SET_PLIM  ,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=MEA_POUT  ,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=MEA_BRT1  ,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=MEA_BRT2  ,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=MEA_PDELAY,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=MEA_FAULTS,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=MEA_PIN   ,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=MEA_VOUT  ,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=MEA_VIN   ,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=MEA_IOUT  ,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=MEA_IIN   ,      (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=MEA_TIMESTAMP,   (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);

                        Msg[1]=BM_SETCHECK;
                        Msg[2]=BST_INDETERMINATE;
                        Msg[3]=0;
                        Msg[0]=SET_ILOOPON   ,          (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=SET_VLOOPON   ,          (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=SET_FREQLOOPON,          (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=SET_FREQSCANON,          (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        Msg[0]=SET_PLOOPON   ,          (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                        (*NetEngine) (SEND_MESSAGE, MyDialogID, (unsigned long)(&Message));
*/

                case SET_CURR:
//                        Message.Hdr=MSG_DEBUG | CAT_MODE;       //ЊҐ­пҐ¬ б г¬®«з «м­®Ј® ­  "вҐЄгйЁҐ ­ бва®©ЄЁ"
//                        Msg[0]=ACK_CURR;        //ЊҐ­пҐ¬ б г¬®«з «м­®Ј® ­  "вҐЄгйЁҐ ­ бва®©ЄЁ"
                case SET_PERM:
                        (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);    //‘в ўЁ¬ Ј «Єг, Є Є п г¦ в ¬ Ґбвм (Ї® г¬®«з ­Ёо "§ иЁў®з­лҐ", Ї® ўҐае­Ґ¬г ЄҐ©бг "вҐЄгйЁҐ")
                        TrakDeadTime = timeGetTime();
                        DoWarning = 1;
                        if (GrabUserInput(&ModbusMain)) return 1;  //ЋиЁЎЄЁ ўў®¤  Ї®«Ґ©, ­ҐзЁб«®ўлҐ бЁ¬ў®«л Ё в. ¤.
//                        RearrangeGraphs (Message.AutoSend);     //Њ®Ј Ё§¬Ґ­Ёвмбп и Ј иЄ «л ўаҐ¬Ґ­Ё? Џа®ўҐаЁ¬!
//                        Message.Len=52;         //Ќ  ўбпЄЁ© б«гз ©
                        Msg[0]=SLIDERSEND, Msg[1]=BM_GETCHECK, Msg[2]=Msg[3]=0;
                        if ((*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg)) {Msg[1]=BM_SETCHECK, Msg[2]=BST_CHECKED, (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);}  //‘в ўЁ¬ Ј «Єг  ўв®-®вЇа ўЄЁ б« ©¤Ґа®ў, Ґб«Ё ¤® нв®Ј® Ўл«  "бҐа п"
//                        Msg[0]=SENDBYREQ , Msg[1]=BM_GETCHECK, Msg[2]=Msg[3]=0;
//                        if ((*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg)) {Msg[1]=BM_SETCHECK, Msg[2]=BST_CHECKED, (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);}  //‘в ўЁ¬ Ј «Єг  ўв®-®вЇа ўЄЁ Ї® § Їа®бг, Ґб«Ё ¤® нв®Ј® Ўл«  "бҐа п"
                        (*NetEngine) (SEND_MESSAGE, MyDialogID, (unsigned long)(&ModbusMain));
                        (*NetEngine) (SEND_MESSAGE, MyDialogID, (unsigned long)(&ModbusSETFlags));
//                        if (DoLog) LogToFile (&Message, "Outgoing: ");
                return 1;
        }

        return 0;
}


//extern "C" int __export __syscall PluginEngine (unsigned long uMsg, unsigned long wParam, unsigned long lParam)
extern "C" int __export WINAPI PluginEngine (long DiaId, unsigned long uMsg, unsigned long wParam, unsigned long lParam)
{
        char Text[256];
        unsigned long Msg[4]={LASTTYPE, WM_SETTEXT,0,(LPARAM)(LPCTSTR)Text};
if (!uMsg) cout<<"WM_NULL "<<wParam<<" "<<lParam<<endl;

        if (!uMsg && (!DialogEngine && !NetEngine || (unsigned long)DialogEngine==wParam && (unsigned long)NetEngine==lParam) )
        {
                DialogEngine=(FWAPI*)(wParam);
                NetEngine=(FWAPI*)(lParam);
                cout<<"Opening a dialog by a template "<<DialogEngine<<endl;
                WCB* PluginEnginePtr[2] = {PluginEngine, NULL};

//DiaTemplate=LoadResource(hinst, FindResource (hinst, "BASE_SET", RT_DIALOG));

		if ((*DialogEngine) (GETDIALOGDATA_HEADER, -1, (unsigned long)(ParamHeaderString)))
		{	//Data prepared by GETDIALOGDATA_HEADER and GETDIALOGDATA_LINE are guaranteed to be valid (as well as their pointers) until next call, so both functions are not thread-safe.
			double *Params;
			for (int i=0; i<TOTAL_REGS; i++)
				if ( Params = (double*) ( (*DialogEngine) (GETDIALOGDATA_LINE, -1, (unsigned long)(ModbusMainINI[i].INIKeyName)) ) )
				{
					ModbusMain.Regs[i] = Params[1] * ModbusMainGUI[i].Scale;
					ModbusMainINI[i].Min = Params[0];
					ModbusMainINI[i].Max = Params[2];
				}// else ModbusMain.Regs[i] = ModbusMainINI[i].Min = ModbusMainINI[i].Max = NAN;	//Regs is zero because not double

		        memset ((char*)&ModbusSETFlags+8, 0, sizeof(ModbusSETFlags)-8);
			for (int i=0; i<TOTAL_SETUP_FLAG_BYTES*8; i++)
				if (ModbusSETFlagsGUI[i].INIKeyName[0])
				 if ( Params = (double*) ( (*DialogEngine) (GETDIALOGDATA_LINE, -1, (unsigned long)(ModbusSETFlagsGUI[i].INIKeyName)) ) )
					ModbusSETFlags.Bytes[i/8] |= (Params[1]!=0) << (i%8);

//cout<<(int)(ModbusSETFlags.Bytes[0])<<" "<<(int)(ModbusSETFlags.Bytes[1])<<endl;

//			double *Params = (double*) ( (*DialogEngine) (GETDIALOGDATA_LINE, -1, (unsigned long)("TestParam")) );
//			if (!Params) cout<<"TestParam is not present in .INI!"<<endl;
//			else for (int i=0; i<4; i++) cout<<Params[i]<<" "; cout<<endl;
		}

                /*MyDialogID = */(*DialogEngine) (OPENDIALOG, (unsigned long)(DiaTemplate), (unsigned long)(&PluginEnginePtr));
//                                 (int*) ( (*NetEngine) (REGISTER_INCOMING, MyDialogID, (unsigned long)(&Message)) );    // Ј , Ё¬Ґ­­® зв® ЇҐаҐ¤ с¬  ¤аҐб ЇҐаў®Ј® н«Ґ¬Ґ­в , в ¬ вЁЇ б®®ЎйҐ­Ёп, Є®в®алҐ ¬л Ўг¤Ґ¬ ЇаЁ­Ё¬ вм; ў® ўв®а®¬ н«Ґ¬Ґ­вҐ -- зЁб«® ®¤­®вЁЇ­ле ¬®¤Ў б-Ї®«Ґ©, зв®Ўл §­ вм, бЄ®«мЄ® § Їа иЁў вм.
//                Message.Hdr=MSG_DEBUG|CAT_MODE; //‚в®а®© "­ и" вЁЇ
//                IncomingBuffer = (int*) ( (*NetEngine) (REGISTER_INCOMING, MyDialogID, (unsigned long)(&ModbusMain)) );    //ЎгдҐа ­  ўбҐ § аҐЈЁбваЁа®ў ­­лҐ б®®ЎйҐ­Ёп ®¤Ё­, ¬®¦­® Ё§ «оЎ®Ј® ўл§®ў  ў§пвм.
                                                //’аҐвЁ© вЁЇ, Ї®в®¬ ўл­ҐбҐ¬ ў ¤агЈ®© Ї«гЈ
//                                 (int*) ( (*NetEngine) (REGISTER_INCOMING, MyDialogID, (unsigned long)(&ResetLogs)) );

                return 0;//(int)("Test point 1");
        }

// TODO!!! SEND IT ON DEVICE RECONNECT!!!
// if (!uMsg && IncomingBuffer && (unsigned long)IncomingBuffer==wParam && IncomingBuffer[1]==lParam ) ModbusMain.Count = TOTALREGS;    //Return to Max Supported

        if (uMsg==WM_COMMAND && lParam && wParam>>16==BN_CLICKED) return DoButton(wParam&0xFFFF);

        if (uMsg==WM_TIMER)     //ЋЎа Ў®вЄ  "®в«®¦Ґ­­ле" ¤саЈ ­Ё© Ї®«§г­Є®ў
        {                
                Msg[0]=0;       //­®¬Ґа в ©¬Ґа 
                Msg[1]=0;       //ўаҐ¬п в ©¬Ґа  = 0 (®вЄ«озЁвм в ©¬Ґа)
                (*DialogEngine) (TIMER, MyDialogID, (int)Msg);

                Msg[0]=SLIDERFREQ, Msg[1]=TBM_GETPOS, Msg[2]=Msg[3]=0;
                int j=(*DialogEngine) ( SENDMDIALOG, MyDialogID, (int)Msg);
                Msg[0]=SET_FREQUANCY, *((double*)(Msg+1))=j / ModbusMainGUI[FREQUANCY].Scale, (*DialogEngine) (DOUBLETOTEXT, MyDialogID, (int)Msg);

                Msg[0]=SLIDERAMPL, Msg[1]=TBM_GETPOS, Msg[2]=Msg[3]=0;
                j=(*DialogEngine) ( SENDMDIALOG, MyDialogID, (int)Msg);
                Msg[0]=SET_I_U, *((double*)(Msg+1))=j / ModbusMainGUI[I_U].Scale, (*DialogEngine) (DOUBLETOTEXT, MyDialogID, (int)Msg);

                Msg[0]=SLIDERSEND, Msg[1]=BM_GETCHECK, Msg[2]=Msg[3]=0;
                if ((*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg) == BST_CHECKED) //‚ нв®в а § бва®Ј® ­Ґ бҐа п.
                        return DoButton (SET_CURR);     //Ђ­ «®ЈЁз­® ­ ¦ вЁо "®вЇа ўЄЁ".
        }

        if (uMsg==WM_HSCROLL)
        {
                int j=wParam>>16;       //‚а ЇЇҐа Ї®§ Ў®вЁ«бп

                Msg[0] = timeGetTime() - TrakDeadTime;//Ѓ« Ј® ®­ г ­ б ЎҐ§§­ Є®ўл©
                if (Msg[0]<100) //‘¬Ґ­  §­ зҐ­Ё© Ї®«Ґ© ­Ґ а ­ҐҐ 1/10 бҐЄг­¤л Ї®б«Ґ Їа®и«®© ®вЇа ўЄЁ!
                {
                        Msg[0]=0;       //­®¬Ґа в ©¬Ґа 
                        Msg[1]=100;     //ўаҐ¬п в ©¬Ґа 
//cout<<"Timer set! "<<
                        (*DialogEngine) (TIMER, MyDialogID, (int)Msg);
//cout<<endl;
                        return 1;
                }

                if (lParam == SLIDERFREQ)       //’®¦Ґ ўа ЇЇҐа Ї®§ Ў®вЁ«бп
                {
                        Msg[0]=SET_FREQUANCY, *((double*)(Msg+1))=j / ModbusMainGUI[FREQUANCY].Scale, (*DialogEngine) (DOUBLETOTEXT, MyDialogID, (int)Msg);
                }
                if (lParam == SLIDERAMPL)       //’®¦Ґ ўа ЇЇҐа Ї®§ Ў®вЁ«бп
                {
                        Msg[0]=SET_I_U, *((double*)(Msg+1))=j / ModbusMainGUI[I_U].Scale, (*DialogEngine) (DOUBLETOTEXT, MyDialogID, (int)Msg);
                }

                Msg[0]=SLIDERSEND, Msg[1]=BM_GETCHECK, Msg[2]=Msg[3]=0;
                if ((*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg) == BST_CHECKED) //‚ нв®в а § бва®Ј® ­Ґ бҐа п.
                        return DoButton (SET_CURR);     //Ђ­ «®ЈЁз­® ­ ¦ вЁо "®вЇа ўЄЁ".

        }
/*        if (uMsg==EN_KILLFOCUS)
        {
cout<<wParam<<" "<<lParam<<endl;
                unsigned long Msg[4]={0, TBM_SETPOS, (WPARAM)(BOOL)TRUE};
                double T;

                if (wParam>>16 == SET_FREQ)
                {
                        Msg[0]=SLIDERFREQ;
                        if (isfinite(T= *((double*)((*DialogEngine)(TEXTTODOUBLE, MyDialogID, SET_FREQ     ))) ))
                        {
                                Msg[3]=T;
                                (*DialogEngine) ( SENDMDIALOG, MyDialogID, (int)Msg);
                        }                       
                }
                if (wParam>>16 == SET_AMPL)
                {
                        Msg[0]=SLIDERAMPL;
                        if (isfinite(T= *((double*)((*DialogEngine)(TEXTTODOUBLE, MyDialogID, SET_AMPL     ))) ))
                        {
                                Msg[3]=T;
                                (*DialogEngine) ( SENDMDIALOG, MyDialogID, (int)Msg);
                        }                       
                }
        }*/

        if (uMsg==WM_INITDIALOG)
        {
		MyDialogID = lParam;
cout<<"Newly created Dialog ID = "<<MyDialogID<<endl;

                unsigned long Msg[4]={0, BM_SETCHECK, (WPARAM)BST_INDETERMINATE, (LPARAM)0};
		for (int i=0; i<TOTAL_SETUP_FLAG_BYTES*8; i++)
		{
                        Msg[0]=ModbusSETFlagsGUI[i].CheckboxId;
                        Msg[1]=(int)(ModbusSETFlagsGUI[i].ToolTip);
                        (*DialogEngine) (ATTACHTOOLTIP, MyDialogID, (int)Msg);
		}

                Msg[0]=SLIDERFREQ, Msg[1]=TBM_SETRANGE, Msg[2]=1, Msg[3]=(LPARAM) MAKELONG( ModbusMainINI[FREQUANCY].Min*ModbusMainGUI[FREQUANCY].Scale, ModbusMainINI[FREQUANCY].Max*ModbusMainGUI[FREQUANCY].Scale );	//0x00, 0x3E8);
                (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
                Msg[0]=SLIDERAMPL,                                Msg[3]=(LPARAM) MAKELONG( ModbusMainINI[I_U].Min*ModbusMainGUI[I_U].Scale, ModbusMainINI[I_U].Max*ModbusMainGUI[I_U].Scale );	//0x00, 0x50);
                (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);

                for (int i=0; i<ModbusMain.Count; i++)
                {
                        Msg[0]=ModbusMainGUI[i].ControlId;
                        Msg[1]=(int)(ModbusMainGUI[i].ToolTip);
                        (*DialogEngine) (ATTACHTOOLTIP, MyDialogID, (int)Msg);

                        *((double*)(Msg+1))=((double)(ModbusMain.Regs[i])) / ModbusMainGUI[i].Scale;
                        (*DialogEngine) (DOUBLETOTEXT, MyDialogID, (int)Msg);
                }

	        Msg[1]=BM_SETCHECK;
	        Msg[3]=0;
                for (int i=0; i<TOTAL_SETUP_FLAG_BYTES*8; i++)
                {
		        Msg[0]=ModbusSETFlagsGUI[i].CheckboxId;
		        Msg[2]=(ModbusSETFlags.Bytes[i/8]>>(i%8)) & 1;
		        (*DialogEngine) (SENDMDIALOG, MyDialogID, (int)Msg);
		}
        }
        
//      return 0xDEADC0DE;
        return 0;
}

BOOL WINAPI DllMain (HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
        if (fdwReason==DLL_PROCESS_ATTACH)
        {
//              hinst=hinstDLL;
                DiaTemplate=LoadResource(hinstDLL, FindResource (hinstDLL, "BASE_SET", RT_DIALOG));
                cout<<"Plug Init "<<DiaTemplate<<" "<<fdwReason<<endl;
//cout<<"Supported Size: "<<sizeof(MsgDebugLogs)<<endl;
        }

        return 1;
}
